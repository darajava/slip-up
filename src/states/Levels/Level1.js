// import Background from '../../objects/Background';
import Player from '../../objects/Player';
import Controls from '../../objects/Controls';
import Coin from '../../objects/Coin';
import Bomb from '../../objects/Bomb';
// import TextOverlay from '../../objects/TextOverlay';
// import LevelEnd from '../../objects/LevelEnd';
// import Level1 from '../objects/Level1';


// todo: probably rename because i think there will only be one long level
class Level1 extends Phaser.State {

  create() {
    // this.game.world.scale.set(window.devicePixelRatio);
    this.game.stage.backgroundColor = "#fff";
    this.midX = window.innerWidth / 2;
    let midY = window.innerHeight / 2;
    let bottomY = window.innerHeight / 3 * 2;
    this.plusPixels = 0;
 
    // this.background = this.game.add.tileSprite(0, 0, 600, 100, 'road');
    // this.background.height = bottomY;
    // this.background.width = 600;

    // this.background.scale.x = (this.game.width / this.background.width);
    this.time = new Date();

    this.line1 = new Phaser.Line(this.midX, 0, this.midX, window.innerHeight);
    this.line2 = new Phaser.Line(0, bottomY, window.innerWidth, bottomY);

    this.joysticks = [
      [
        this.midX / 2,
        (window.innerHeight + bottomY) / 2,
      ],
      [
        this.midX / 2 * 3,
        (window.innerHeight + bottomY) / 2,
      ],
    ];

    this.players = [
      new Player(this.game, [this.midX / 2, midY]),
      new Player(this.game, [this.midX / 2 * 3, midY]),
    ]

    this.controls = [
      new Controls(this.game, this.joysticks[0], this.players[0].update),
      new Controls(this.game, this.joysticks[1], this.players[1].update),
    ];

    // these lines generated by parseLevel.js
this.coins1 = [[],[],[],[],[],[],[],[],[6],[],[6],[],[2],[],[2],[],[6],[],[6],[],[2],[],[2],[],[6],[],[2,6],[],[2,6],[],[],[],[]];
this.coins2 = [[],[],[],[],[],[],[],[],[2],[],[6],[],[2],[],[6],[],[2],[],[6],[],[2],[],[5,6],[],[2,3],[],[2,6],[],[2,6],[],[],[],[]];
this.bombs1 = [[],[],[],[],[],[],[],[],[0,8],[],[0,8],[],[0,8],[],[0,8],[],[0,8],[],[0,8],[],[0,8],[],[0,8],[],[0,4,8],[],[0,8],[4],[0,8],[],[],[],[]];
this.bombs2 = [[],[],[],[],[],[],[],[],[0,8],[],[0,8],[],[0,8],[],[0,8],[],[0,8],[],[0,8],[],[0,8],[],[0,8],[],[0,8],[4],[0,8],[4],[0,8],[],[],[],[]];

    this.group = this.game.add.physicsGroup();

    this.limit = 40;
    this.lastCoinGenerated1 = this.limit;
    this.lastCoinGenerated2 = this.limit;

    for (let i = 0; i < this.limit; i++) {
      this.addCoinRow(i, this.coins1[i]);
    }

    for (let i = 0; i < this.limit; i++) {
      this.addCoinRow(i, this.coins2[i], true);
    }

    for (let i = 0; i < this.bombs1.length; i++) {
      this.addBomb(i, this.bombs1[i]);
    }

    for (let i = 0; i < this.bombs2.length; i++) {
      this.addBomb(i, this.bombs2[i], true);
    }

    this.drawLine(this.line1)
    this.drawLine(this.line2)

    // this.addCoinRowToGroup = this.addCoinRowToGroup.bind(this)
  }

  addCoinRow(y, coinArr, player2) {
    let step = 80;
    let timePassed = (new Date() - this.time) / 1000;

    if (typeof coinArr === 'undefined') return;

    for (let i = 0; i < coinArr.length; i++) {
      let coin = new Coin(
          this.game,
          27 + coinArr[i] * (this.midX / 9) + (player2 ? this.midX : 0),
          (-(y * step)) + this.plusPixels,
          this.players[0],
        ).getSprite();

      coin.inputEnabled = true;
      this.group.add(coin);
    }
  }


  addBomb(y, bombArr, player2) {
    let step = 80;

    for (let i = 0; i < bombArr.length; i++)
      this.group.add(
        new Bomb(
          this.game,
          27 + bombArr[i] * (this.midX / 9) + (player2 ? this.midX : 0),
          -(y * step),
          this.players[0]
        ).getSprite()
      );
  }

  drawLine(line) {
    let graphics = this.game.add.graphics(0,0);
    //var graphics=game.add.graphics(line.start.x,line.start.y);//if you have a static line
    graphics.lineStyle(10, 0x000000, 1);
    graphics.moveTo(line.start.x,line.start.y);//moving position of graphic if you draw mulitple lines
    graphics.lineTo(line.end.x,line.end.y);
    graphics.endFill();
  }

  fixDensity() {
  
  }

  update() {
    this.game.physics.arcade.collide(
      this.players[0].getSprite(),
      this.group,
      this.collisionHandler,
      this.processHandler,
      this
    );

    this.game.physics.arcade.collide(
      this.players[1].getSprite(),
      this.group,
      this.collisionHandler,
      this.processHandler,
      this
    );


    let count = 0;
      while (this.group.children.length < this.limit) {
        this.addNewDot();
        if (count++ > 100) {
          break;
        }
      }

    console.log('groupLength', this.group.children.length);
    for (let i = 0; i < this.group.children.length; i++) {

      // Check if it's not a bomb
      if (this.group.children[i].body.width > 50 && this.group.children[i].body.position.y > this.game.height / 3 * 2) {
        this.game.state.start("Level1");
        this.game.sound.play("lose");
        this.group.remove(this.group.children[i]);
        // this.collisionHandler();
      }

      if (!this.group.children[i].alive) {
        let spriteToRemove = this.group.children[i];
        this.group.remove(spriteToRemove);
        spriteToRemove.destroy();
      }

      if (this.group.children[i])
        this.group.children[i].body.position.y += 5;

    }
    
    this.plusPixels += 5;
  }

  processHandler(player, coin) {
    return true;
  }

  collisionHandler(player, coin) {
    // console.log('collisionHandler')
    // coin.kill();
    // player.body.velocity.y = 0;
    // console.log('len', this.group.length);

  }

  addNewDot() {
    // this.addAgain = !this.addAgain

    // if (this.addAgain) {
    {
      let startingPoint = this.lastCoinGenerated1;

      if (startingPoint < this.coins1.length) 
        do {
            this.addCoinRow(startingPoint, this.coins1[startingPoint]);
        } while(typeof this.coins1[startingPoint] !== 'undefined' && this.coins1[startingPoint++].length === 0)

      this.lastCoinGenerated1 = startingPoint;

      let startingPoint2 = this.lastCoinGenerated2;
      if (startingPoint2 < this.coins2.length) 
        do {
            this.addCoinRow(startingPoint2, this.coins2[startingPoint2], true);
        } while(typeof this.coins2[startingPoint2] !== 'undefined' && this.coins2[startingPoint2++].length === 0)

      this.lastCoinGenerated2 = startingPoint2;

    }
  }

}

export default Level1;
